<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Codility on Life Beyond Rails</title>
    <link>http://life.beyondrails.com/categories/codility/index.xml</link>
    <description>Recent content in Codility on Life Beyond Rails</description>
    <generator>Hugo -- gohugo.io</generator>
    <atom:link href="http://life.beyondrails.com/categories/codility/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Codility - PermMissingElem</title>
      <link>http://life.beyondrails.com/blog/2015/10/30/codility---permmissingelem/</link>
      <pubDate>Fri, 30 Oct 2015 04:16:00 -0800</pubDate>
      
      <guid>http://life.beyondrails.com/blog/2015/10/30/codility---permmissingelem/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://codility.com/programmers/task/perm_missing_elem&#34;&gt;https://codility.com/programmers/task/perm_missing_elem&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;my-solution&#34;&gt;My solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def solution(a)
  return 1 if a.empty?

  # edge case, N + 1 is missing
  # but unlike the case below, we can immediately compute and return this
  if a.length == 1
    return 2 if a[0] == 1
    return 1 if a[0] == 2
  end

  sorted = a.sort
  sorted.each_index do |index|
    return index + 1 if(sorted[index] != index + 1)
  end

  # edge case, N + 1 is missing
  return a.length + 1
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;learning-points&#34;&gt;Learning points&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Edge cases are always tricky! Always get into the habit of asking: what can go wrong? Good questions to ask are: what about empty inputs, beginning/ending elements are missing.&lt;/li&gt;
&lt;li&gt;I have a feeling that for the other languages, you need to implement your own sorting algorithm (like bubble sort).&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Codility - FrogJmp</title>
      <link>http://life.beyondrails.com/blog/2015/10/30/codility---frogjmp/</link>
      <pubDate>Fri, 30 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://life.beyondrails.com/blog/2015/10/30/codility---frogjmp/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://codility.com/programmers/task/frog_jmp&#34;&gt;https://codility.com/programmers/task/frog_jmp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;my-solution&#34;&gt;My solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def solution(x, y, d)
  ((y - x).to_f / d).ceil
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;learning-points&#34;&gt;Learning points&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Paper and pencil (and algebra) helps. The equation is: &lt;code&gt;x + dn &amp;gt;= y&lt;/code&gt; After that it was just a matter of finding &lt;code&gt;n&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Integer division can be tricky. Convert to &lt;code&gt;float&lt;/code&gt; to retain precision, then convert back to &lt;code&gt;integer&lt;/code&gt; afterwards (if the situation requires it).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#to_i&lt;/code&gt; will chop off the decimal portion of the float; this may or may not be what you want.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O(1)&lt;/code&gt; will usually mean there should be no loop used &amp;ndash; at all. It is a straightforward computation.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Codility - TapeEquilibrium</title>
      <link>http://life.beyondrails.com/blog/2015/10/30/codility---tapeequilibrium/</link>
      <pubDate>Fri, 30 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://life.beyondrails.com/blog/2015/10/30/codility---tapeequilibrium/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://codility.com/programmers/task/tape_equilibrium&#34;&gt;https://codility.com/programmers/task/tape_equilibrium&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;my-solution&#34;&gt;My solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def solution(a)
  first_sum = a[0]
  second_sum = a[1..-1].reduce(0, :+)
  min_diff = (first_sum - second_sum).abs

  a.each_index do |p|
    next if p == 0
    next if p == a.length - 1

    first_sum = first_sum + a[p]
    second_sum = second_sum - a[p]
    diff = (first_sum - second_sum).abs
    min_diff = diff if diff &amp;lt; min_diff
  end

  min_diff
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;learning-points&#34;&gt;Learning points&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Take note of the complexity and how additional magnitude might creep in (e.g. using &lt;code&gt;#reduce&lt;/code&gt; inside the &lt;code&gt;#each_index&lt;/code&gt; block).&lt;/li&gt;
&lt;li&gt;Recomputing over and over is wasteful. Try to find ways to cache values and manipulate them within the complexity. In this case, the sums are cached and the element under the moving index added and subtracted accordingly. This avoids recomputing the &lt;code&gt;first_sum&lt;/code&gt; and the &lt;code&gt;second_sum&lt;/code&gt; for every loop iteration.&lt;/li&gt;
&lt;li&gt;Take care of edge cases. In this case, since the &lt;code&gt;first_sum&lt;/code&gt; and the &lt;code&gt;second_sum&lt;/code&gt; had already been precomputed, we need to skip them during the loop iteration.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>